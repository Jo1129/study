
1.실행계획

explain plan for

select * from emp where sal like '30%';

select  * from table(dbms_xplan.display);


2.group by 할때
null은 포함 안하기 때문에 nvl 이용


3.rank
select ename , job , sal , rank() over (order by sal desc ) -- 월급 내림차순대로 순위 랭크해라
from emp
where job in ( 'ANALYST' , 'MANAGER')



select ename , deptno , sal , dense_rank() over (order by sal desc )   -- rank() over 는 1 1 3    dense_rank() 는 1 1 2 
from emp
where deptno = 20

select job , ename , sal , dense_rank() over (partition by job order by sal desc)  -- 직업별로 각각 partition by   group by 같은거
from emp


select dense_rank(2975) within group(order by sal desc) -- 순위 월급을 높은 순위로 정렬해놓은 그룹 안에 2975인 값이 몇위
from emp

select ename , job , sal  , ntile(4) over (order by sal desc) 등급 -- sal 등급 4로 나누기
from emp

select ename , hiredate  , ntile(5) over (order by hiredate asc) -- 입사한 순서대로 5등급 나누기
from emp


select ename , sal , dense_rank() over (order by sal desc) 순위 , 
                    round(cume_dist() over (order by sal desc) , 2) 비율 -- over뜻 확장하다  순위별 백분율
from emp

select deptno , ename , sal ,  
        cume_dist() over (partition by deptno order by sal desc) 순위  -- 부서번호 별로 각각 월급 비율
from emp

4. 데이터 가로 출력 listagg

select deptno , 
       listagg(ename, ',') within group (order by ename asc) as 이름   -- 부서번호별로 사원이름 출력
from emp
group by deptno;       -- group by 꼭 필요  

select job , 
      listagg(ename , ',') WITHIN group ( order by sal desc ) as 이름
from emp
group by job;       -- group by 꼭 필요  



5. 바로 전행과 다음행 출력하기 LAG 이전행 , LEAD 다음행

select empno , ename ,sal , lag(sal , 1) over (order by sal asc) 전행,  -- 전행 1 전전행2 
                            lead(sal , 1) over (order by sal asc) 다음행
from emp

select ename , hiredate , 
        hiredate - lag(hiredate , 1) over (order by hiredate asc) as 간격,   -- 전입사자랑 비교 일 유용할거같음
        lead(hiredate , 1) over (order by hiredate asc)
        from emp


6. 가로세로 변경 decode

select deptno , sum(sal)
from emp
group by deptno;

select sum(decode(deptno , 10 , sal )) as "10",
       sum(decode(deptno , 20 , sal )) as "20",
       sum(decode(deptno , 30 , sal )) as "30"
from emp;


select * from
( select deptno , sal from emp ) 
pivot ( sum(sal) for deptno in (10 , 20 , 30) );

