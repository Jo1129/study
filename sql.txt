
1.실행계획

explain plan for

select * from emp where sal like '30%';

select  * from table(dbms_xplan.display);


2.group by 할때
null은 포함 안하기 때문에 nvl 이용


3.rank
select ename , job , sal , rank() over (order by sal desc ) -- 월급 내림차순대로 순위 랭크해라
from emp
where job in ( 'ANALYST' , 'MANAGER')



select ename , deptno , sal , dense_rank() over (order by sal desc )   -- rank() over 는 1 1 3    dense_rank() 는 1 1 2 
from emp
where deptno = 20

select job , ename , sal , dense_rank() over (partition by job order by sal desc)  -- 직업별로 각각 partition by   group by 같은거
from emp


select dense_rank(2975) within group(order by sal desc) -- 순위 월급을 높은 순위로 정렬해놓은 그룹 안에 2975인 값이 몇위
from emp

select ename , job , sal  , ntile(4) over (order by sal desc) 등급 -- sal 등급 4로 나누기
from emp

select ename , hiredate  , ntile(5) over (order by hiredate asc) -- 입사한 순서대로 5등급 나누기
from emp


select ename , sal , dense_rank() over (order by sal desc) 순위 , 
                    round(cume_dist() over (order by sal desc) , 2) 비율 -- over뜻 확장하다  순위별 백분율
from emp

select deptno , ename , sal ,  
        cume_dist() over (partition by deptno order by sal desc) 순위  -- 부서번호 별로 각각 월급 비율
from emp

4. 데이터 가로 출력 listagg

select deptno , 
       listagg(ename, ',') within group (order by ename asc) as 이름   -- 부서번호별로 사원이름 출력
from emp
group by deptno;       -- group by 꼭 필요  

select job , 
      listagg(ename , ',') WITHIN group ( order by sal desc ) as 이름
from emp
group by job;       -- group by 꼭 필요  



5. 바로 전행과 다음행 출력하기 LAG 이전행 , LEAD 다음행

select empno , ename ,sal , lag(sal , 1) over (order by sal asc) 전행,  -- 전행 1 전전행2 
                            lead(sal , 1) over (order by sal asc) 다음행
from emp

select ename , hiredate , 
        hiredate - lag(hiredate , 1) over (order by hiredate asc) as 간격,   -- 전입사자랑 비교 일 유용할거같음
        lead(hiredate , 1) over (order by hiredate asc)
        from emp


6. 가로세로 변경 decode

select deptno , sum(sal)
from emp
group by deptno;

select sum(decode(deptno , 10 , sal )) as "10",
       sum(decode(deptno , 20 , sal )) as "20",
       sum(decode(deptno , 30 , sal )) as "30"
from emp;


select * from
( select deptno , sal from emp ) 
pivot ( sum(sal) for deptno in (10 , 20 , 30) );



SELECT *
 FROM order2
 UNPIVOT ( 건수 for 아이템 in ( BICYCLE, CAMERA, NOTEBOOK ) );


7. sum over
select empno, deptno ,  ename , sal,  sum(sal) over(order by empno asc) 누적치
from emp


select empno, deptno ,  ename , sal,  sum(sal) over(order by empno rows between unbounded preceding  -- 제일 첫번째 행
                                                                and current row) 누적치           -- 현재행
from emp

--비율
select empno , ename , sal , ratio_to_report(sal) over() 비율  -- 원형그래프 참고 비율 컬럼 보여줌
from emp

-- 전체 금액
select deptno , sum(sal)
from emp 
group by deptno

union all 

select to_number(null) as deptno ,sum(sal)
from emp

order by deptno asc

-- 함수이용시
select deptno , sum(sal)
from emp
group by rollup(deptno); -- 맨 하단행에 전체 합계


select deptno , sum(sal)
from emp
group by CUBE(deptno);  -- 맨 상단에 전체 합계

select to_char(hiredate, 'RRRR') , sum(sal)
from emp
group by CUBE(to_char(hiredate, 'RRRR'))


--그룹핑 
select deptno , job , sum(sal)
from emp
group by grouping sets ( (deptno) , 
                         (job) , 
                          ())   --전체

select to_char(hiredate, 'RRRR') , job,  sum(sal)
from emp
group by grouping sets ( (to_char(hiredate , 'RRRR')) , (job)  )

--넘버링 row_number
select empno , ename ,sal , rank() over(order by sal desc)as rank , 
                           dense_rank() over(order by sal desc) as dense_rank  ,
                          row_number() over(order by sal desc)번호
from emp

--정렬 rownum
select ename , sal , row_number() over(order by ename desc) 
from emp
where sal between 1000 and 3000;


select rownum  , empno , ename , job , sal
from emp
where rownum <=5

-- simple top-n queries
select empno , ename , job , sal 
from emp
order by sal desc fetch first 4 rows only;



--union all 중복제거x 
--UNION 사용 시 중복을 제거하기 위하여 데이터를 모두 검사하기 때문에 속도가 느리다.
select deptno , sum(sal)
from emp 
group by deptno

union all 

select to_number(null) as deptno ,sum(sal)
from emp

order by deptno asc


-- 교집합 intersect

select ename,sal,job,deptno
from emp 
where deptno in  (10,20)


intersect 

select ename,sal,job,deptno
from emp 
where deptno in  (20,30)



--차집합 A-B 

select ename,sal,job,deptno
from emp 
where deptno in (10,20)

MINUS 

select ename,sal,job,deptno
from emp 
where deptno in (20,30)
